var documenterSearchIndex = {"docs":
[{"location":"functions/","page":"Functions","title":"Functions","text":"CurrentModule = RecombTools\nDocTestSetup  = quote\n    using TreeTools\nend\t","category":"page"},{"location":"functions/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Pages = [\"functions.md\"]","category":"page"},{"location":"functions/#Computing-Maximal-Compatible-Clades-(MCCs)-for-a-set-of-trees","page":"Functions","title":"Computing Maximal Compatible Clades (MCCs) for a set of trees","text":"","category":"section"},{"location":"functions/#Main-functions","page":"Functions","title":"Main functions","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"computeMCCs\ncomputeMCCs!","category":"page"},{"location":"functions/#RecombTools.computeMCCs","page":"Functions","title":"RecombTools.computeMCCs","text":"computeMCCs(\n\ttrees::Dict{<:Any, <:Tree}, oa::OptArgs=OptArgs();\n\tpreresolve=true, naive=false\n)\n\nCompute pairwise MCCs for trees. Return MCCs and resolved splits. The computeMCCs! version resolved the input trees with newly found splits.\n\nInputs\n\noa::OptArgs\n\nControls parameters of the MCC inference (unless naive=true). See ?OptArgs for details.\n\npreresolve = true\n\nIf true, a first pass of MCC computation is made and trees are resolved using the results, keeping only compatible splits if more than two trees are given as input. A second pass of MCC computation is then made without resolving.\nElse, only the first pass is performed. For more than two trees, this may find MCCs that introduce incompatible splits in case of poorly resolved input trees.\n\nnaive = false\n\nIf true, use a naive estimation for MCCs, i.e. find all clades that have an exactly matching topology in all trees.\nElse, use a pseudo-parsimonious method based (mostly) on topology. The method runopt(oa,t1,t2) is called on every pair of trees. by calling function runopt(oa,t1,t2) on pairs of trees. Return MCCs and resolved splits.\n\noutput = :mccs\n\nControl the type of output. If :mccs, only MCCs are returned. If :all, splits added \tin trees during the inference process are returned as well.\n\n\n\n\n\n","category":"function"},{"location":"functions/#RecombTools.computeMCCs!","page":"Functions","title":"RecombTools.computeMCCs!","text":"computeMCCs!(\n\ttrees::Dict{<:Any, <:Tree}, oa::OptArgs=OptArgs();\n\tpreresolve=true, naive=false\n)\n\nSee computeMCCs.\n\n\n\n\n\n","category":"function"},{"location":"functions/#For-pairs-of-trees-only","page":"Functions","title":"For pairs of trees only","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"naive_mccs\nRecombTools.runopt","category":"page"},{"location":"functions/#RecombTools.naive_mccs","page":"Functions","title":"RecombTools.naive_mccs","text":"naive_mccs(treelist)\n\nFind sets of nodes which are:\n\nclades in all trees of treelist,\nall subclades of nodes are clades in all trees of treelist (both of these properties define consistency),\nmaximal: adding a node to a set results it in not being a clade in at least one of the trees.\n\nAll the trees of treelist should share the same leaf nodes.\n\n\n\n\n\n","category":"function"},{"location":"functions/#RecombTools.runopt","page":"Functions","title":"RecombTools.runopt","text":"\trunopt(t1::Tree, t2::Tree; kwargs...)\n\trunopt(oa::OptArgs, t1::Tree, t2::Tree)\n\trunopt(oa::OptArgs, trees::Dict{<:Any,<:Tree})\n\nRun optimization at constant γ. See ?Optargs for arguments. In the first form, keyword   arguments are given to OptArgs.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Resolving-trees","page":"Functions","title":"Resolving trees","text":"","category":"section"},{"location":"functions/#Using-topology","page":"Functions","title":"Using topology","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"resolve!(::TreeTools.Tree, ::TreeTools.Tree)","category":"page"},{"location":"functions/#RecombTools.resolve!-Tuple{TreeTools.Tree, TreeTools.Tree}","page":"Functions","title":"RecombTools.resolve!","text":"resolve!(t1::Tree, t2::Tree; tau=0.)\n\nResolve t1 using splits of t2 and inversely. Every split of t2 a tree that is compatible with t1 is introduced in t1 (and inversely). Return new splits in each tree.\n\n\n\n\n\n","category":"method"},{"location":"usage/#Usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"usage/#Simple-case","page":"Usage","title":"Simple case","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Let's see how to infer MCCs for a very simple case: two trees with five leaves. ","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using RecombTools, TreeTools\nt1 = node2tree(parse_newick(\"((A,B),(C,(D,X)))\"))\nt2 = node2tree(parse_newick(\"((A,(B,X)),(C,D))\"))","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"The computeMCCs function takes a dictionary of trees as input.  It would normally be indexed by e.g. flu segments, but here we will simply index it with integers.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"trees = Dict(1=>t1, 2=>t2)\nmccs = computeMCCs(trees)\nmccs[1,2]","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Individual MCCs are simply arrays containing labels of leaves of the trees.  ","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Note that the output of computeMCCs is a dictionary, indexed by pairs of keys of the input trees.  This is mostly practical when computing MCCs for more than two trees: ","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"t3 = node2tree(parse_newick(\"((A,B),(C,(D,X)))\")) # t3 is equal to t1\ntrees[3] = t3\nmccs = computeMCCs(trees)\nmccs[1,3]","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"By convention, mccs[1,1] and mccs[2,2] are empty. ","category":"page"},{"location":"usage/#Degeneracy","page":"Usage","title":"Degeneracy","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"using RecombTools, TreeTools # hide\nt1 = node2tree(parse_newick(\"((A:2,B:2):2,C:4)\"))\nt2 = node2tree(parse_newick(\"(A:2,(B:1,C:1):1)\"))\ntrees = Dict(1=>t1, 2=>t2)\noa = OptArgs(likelihood_sort = false)\nunique([computeMCCs(trees, oa)[1,2] for rep in 1:10])","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"oa = OptArgs(likelihood_sort = true)\nunique([computeMCCs(trees, oa)[1,2] for rep in 1:10])","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"CurrentModule = RecombTools\nDocTestSetup  = quote\n    using TreeTools\nend\t","category":"page"},{"location":"types/#The-OptArgs-object","page":"Types","title":"The OptArgs object","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"computeMCCs and several other functions take an OptArgs object that controls several parameters of the inference process. ","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"OptArgs","category":"page"},{"location":"types/#RecombTools.OptArgs","page":"Types","title":"RecombTools.OptArgs","text":"struct OptArgs\n\nStoring parameters for SplitGraph.runopt function.\n\nGeneral\n\nγ::Real = 3\nitmax::Int64 = 15: Maximal number of iterations of MCC / SA cycles\nlikelihood_sort::Bool = true: sort equivalent configurations using likelihood test (based on branch length for now).\nresolve::Bool = true: try to resolve trees while finding MCCs.\nseq_lengths = ones(Int64, 2): lengths of sequences that trees were built from\ncrossmap_resolve::Bool = false: Use cross-mapped mutations to resolve polytomies in the tree.  Require each leaf's data to have :selfseq and :cmseq entries.\ncrossmap_prune::Bool = false: Use cross-mappped mutations to prune MCCs preventively. The code will look at the number of suspicious mutations at n.data.dat[:suspicious_muts][s] where n = trees[s] (s is assumed to be an influenza segment). Require each leaf's data to have :selfseq and :cmseq entries.\nsuspmut_threshold::Int = 1: Minimal number of suspicious mutation to prune a branch.\n\nSimulated annealing\n\nMd::Real = 10:  Number of SA iterations (per temperature) for a tree of n leaves is ceil(Int64, n/Md)\nTmin::Float64 = 1e-3: Minimal temperature of SA\nTmax::Float64 = 1: Maximal temperature of SA\ndT::Float64 = 1e-2: Temperature step\n\nVerbosity\n\nverbose::Bool=false: first level of verbosity\nvv::Bool = false: second level of verbosity\n\nOutput\n\noutput = :mccs: possible values [:mccs, :mccs_df, :all]\n\n\n\n\n\n","category":"type"}]
}
