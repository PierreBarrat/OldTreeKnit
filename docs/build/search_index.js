var documenterSearchIndex = {"docs":
[{"location":"functions/","page":"Functions","title":"Functions","text":"CurrentModule = RecombTools\nDocTestSetup  = quote\n    using TreeTools\nend\t","category":"page"},{"location":"functions/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Pages = [\"functions.md\"]","category":"page"},{"location":"functions/#Computing-Maximal-Compatible-Clades-(MCCs)-for-a-set-of-trees","page":"Functions","title":"Computing Maximal Compatible Clades (MCCs) for a set of trees","text":"","category":"section"},{"location":"functions/#Main-functions","page":"Functions","title":"Main functions","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"computeMCCs\ncomputeMCCs!","category":"page"},{"location":"functions/#RecombTools.computeMCCs","page":"Functions","title":"RecombTools.computeMCCs","text":"computeMCCs(\n\ttrees::Dict{<:Any, <:Tree}, oa::OptArgs=OptArgs();\n\tpreresolve=true, naive=false\n)\n\nCompute pairwise MCCs for trees. Return MCCs and resolved splits. The computeMCCs! version resolved the input trees with newly found splits.\n\nInputs\n\noa::OptArgs\n\nControls parameters of the MCC inference (unless naive=true). See ?OptArgs for details.\n\npreresolve = true\n\nIf true, a first pass of MCC computation is made and trees are resolved using the results, keeping only compatible splits if more than two trees are given as input. A second pass of MCC computation is then made without resolving.\nElse, only the first pass is performed. For more than two trees, this may find MCCs that introduce incompatible splits in case of poorly resolved input trees.\n\nnaive = false\n\nIf true, use a naive estimation for MCCs, i.e. find all clades that have an exactly matching topology in all trees.\nElse, use a pseudo-parsimonious method based (mostly) on topology. The method runopt(oa,t1,t2) is called on every pair of trees. by calling function runopt(oa,t1,t2) on pairs of trees. Return MCCs and resolved splits.\n\n\n\n\n\n","category":"function"},{"location":"functions/#RecombTools.computeMCCs!","page":"Functions","title":"RecombTools.computeMCCs!","text":"computeMCCs!(\n\ttrees::Dict{<:Any, <:Tree}, oa::OptArgs=OptArgs();\n\tpreresolve=true, naive=false\n)\n\nSee computeMCCs.\n\n\n\n\n\n","category":"function"},{"location":"functions/#For-pairs-of-trees-only","page":"Functions","title":"For pairs of trees only","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"naive_mccs\nRecombTools.runopt","category":"page"},{"location":"functions/#RecombTools.naive_mccs","page":"Functions","title":"RecombTools.naive_mccs","text":"naive_mccs(treelist)\n\nFind sets of nodes which are:\n\nclades in all trees of treelist,\nall subclades of nodes are clades in all trees of treelist (both of these properties define consistency),\nmaximal: adding a node to a set results it in not being a clade in at least one of the trees.\n\nAll the trees of treelist should share the same leaf nodes.\n\n\n\n\n\n","category":"function"},{"location":"functions/#RecombTools.runopt","page":"Functions","title":"RecombTools.runopt","text":"\trunopt(t1::Tree, t2::Tree; kwargs...)\n\trunopt(oa::OptArgs, t1::Tree, t2::Tree)\n\trunopt(oa::OptArgs, trees::Dict{<:Any,<:Tree})\n\nRun optimization at constant Î³. See ?Optargs for arguments. In the first form, keyword   arguments are given to OptArgs.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Resolving-trees","page":"Functions","title":"Resolving trees","text":"","category":"section"},{"location":"functions/#Using-topology","page":"Functions","title":"Using topology","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"resolve!(::TreeTools.Tree, ::TreeTools.Tree)","category":"page"},{"location":"functions/#RecombTools.resolve!-Tuple{TreeTools.Tree,TreeTools.Tree}","page":"Functions","title":"RecombTools.resolve!","text":"resolve!(t1::Tree, t2::Tree; tau=0.)\n\nResolve t1 using splits of t2 and inversely. Every split of t2 a tree that is compatible with t1 is introduced in t1 (and inversely). Return new splits in each tree.\n\n\n\n\n\n","category":"method"}]
}
