./Project.toml:name = "RecombTools"
./README.md:[![](https://img.shields.io/badge/docs-stable-blue.svg)](https://pierrebarrat.github.io/RecombTools)
./README.md:# RecombTools
./README.md:RecombTools is a package that performs the inference of Ancestral Reassortment Graph for segmented genomes (typically, human influenza). 
./Comonicon.toml:name = "RecombTools"
./.git/logs/HEAD:0000000000000000000000000000000000000000 c0f55c3504e81b54db31b94a96e8a4f5c9332e81 PierreBarrat <p.barrat@live.fr> 1623415506 +0200	clone: from https://github.com/PierreBarrat/RecombTools
./.git/logs/HEAD:8d65ea1f172a1bd33ca17af66b150b6d7312a982 02553bf14db0992819cb4216bfbbe14f08103bd1 PierreBarrat <p.barrat@live.fr> 1623664804 +0200	commit: move consistent_mcc_triplets to TestRecombTools
./.git/logs/refs/heads/master:0000000000000000000000000000000000000000 c0f55c3504e81b54db31b94a96e8a4f5c9332e81 PierreBarrat <p.barrat@live.fr> 1623415506 +0200	clone: from https://github.com/PierreBarrat/RecombTools
./.git/logs/refs/heads/master:8d65ea1f172a1bd33ca17af66b150b6d7312a982 02553bf14db0992819cb4216bfbbe14f08103bd1 PierreBarrat <p.barrat@live.fr> 1623664804 +0200	commit: move consistent_mcc_triplets to TestRecombTools
./.git/logs/refs/remotes/origin/master:0000000000000000000000000000000000000000 c0f55c3504e81b54db31b94a96e8a4f5c9332e81 PierreBarrat <p.barrat@live.fr> 1623415506 +0200	clone: from https://github.com/PierreBarrat/RecombTools
./.git/logs/refs/remotes/origin/REF/w_mut_crossmap:0000000000000000000000000000000000000000 0edd966e67eebda554f5833427f0ef284d1be7f9 PierreBarrat <p.barrat@live.fr> 1623415506 +0200	clone: from https://github.com/PierreBarrat/RecombTools
./.git/logs/refs/remotes/origin/tree_inf:0000000000000000000000000000000000000000 d9ef8274fc575fe5c0b9b5de817bdb2a720ce198 PierreBarrat <p.barrat@live.fr> 1623415506 +0200	clone: from https://github.com/PierreBarrat/RecombTools
Fichier binaire ./.git/index correspondant
./.git/config:	url = https://github.com/PierreBarrat/RecombTools
Fichier binaire ./.git/objects/pack/pack-fff8ba23170c6266108fb57eb4a32460da15ebfc.pack correspondant
./.git/FETCH_HEAD:17f4e45a7225b5798a0a94344502b05bf6ebbceb		branch 'master' of https://github.com/PierreBarrat/RecombTools
./.git/FETCH_HEAD:0edd966e67eebda554f5833427f0ef284d1be7f9	not-for-merge	branch 'REF/w_mut_crossmap' of https://github.com/PierreBarrat/RecombTools
./deps/build.log:[ Info: generating /home/pierrebc/.julia/bin/RecombTools.jl
./deps/build.log:[ Info: generating /home/pierrebc/.julia/bin/RecombTools
./deps/build.log:│        @ RecombTools ~/.julia/packages/Comonicon/9x3SY/src/cast.jl:213
./deps/build.log:│        @ ~/Documents/julia/dev/RecombTools/deps/build.jl:2
./docs/src/functions.md:CurrentModule = RecombTools
./docs/src/functions.md:RecombTools.runopt
./docs/src/index.md:# RecombTools
./docs/src/index.md:*RecombTools* relies on the non-registered julia package *TreeTools*, that you have to install first. 
./docs/src/index.md:  After that, simply install *RecombTools* from the url of this github repo: 
./docs/src/index.md:Pkg.add(url="https://github.com/PierreBarrat/RecombTools#master")
./docs/src/index.md:You should now be able to use `using RecombTools`.  
./docs/src/index.md:Pkg.build("RecombTools")
./docs/src/flu_example.md:*RecombTools* includes the small submodule *Flu* that contains convenient functions when working with influenza trees. 
./docs/src/flu_example.md:using RecombTools
./docs/src/flu_example.md:	"ha" => dirname(pathof(RecombTools)) * "/../examples/tree_h3n2_ha_2013-09.nwk",
./docs/src/flu_example.md:	"na" => dirname(pathof(RecombTools)) * "/../examples/tree_h3n2_na_2013-09.nwk"
./docs/src/flu_example.md:  Some tree builders introduce branches of insignificant length in trees to make them binary, which conflicts with the topological approach used by `RecombTools`. 
./docs/src/overview.md:`RecombTools` offers a simple CLI script: `treeknit`. 
./docs/src/overview.md:    Tree builders sometimes introduce branches of insignificant length in order to resolve polytomies and obtain binary trees. Since `RecombTools` relies on topological differences between trees, it is important to remove these branches prior to passing the trees to `treeknit`. This can be done by using only branches with high bootstrap value (typically, $>75$), or by removing branches shorter than, *e.g.*, $(L/2)^{-1}$, where $L$ is the length of the sequences. 
./docs/src/overview.md:    The result `RecombTools` depend how the trees are rooted. It is important that the two trees are rooted in a consistent way. We recommend using the same outgroup for rooting both trees.
./docs/src/opttrees.md:The core of the heuristic *RecombTools* is based on happens in the `opttrees` function, found in the `SplitGraph` submodule. 
./docs/src/opttrees.md:using RecombTools# hide
./docs/src/opttrees.md:mcc_names = RecombTools.name_mcc_clades!(treelist, mcc)
./docs/src/opttrees.md:	treelist[i] = RecombTools.reduce_to_mcc(t, mcc)
./docs/src/opttrees.md:    The `SplitGraph` type and some of the functions used below are in the *SplitGraph* submodule of *RecombTools*. Access them by calling `using RecombTools.SplitGraph` and preceding the calls by `SplitGraph.`
./docs/src/opttrees.md:using RecombTools.SplitGraph
./docs/src/types.md:CurrentModule = RecombTools
./docs/src/runopt.md:using RecombTools
./docs/src/runopt.md:using RecombTools.SplitGraph
./docs/src/runopt.md:mcc_names = RecombTools.name_mcc_clades!(treelist, mccs_naive)
./docs/src/runopt.md:  treelist[i] = RecombTools.reduce_to_mcc(t, mccs_naive)
./docs/src/runopt.md:RecombTools.pruneconf!(mccs_found, treelist...) # prune clades in a list of trees. Wrapper around TreeTools.prunesutree!
./docs/src/runopt.md:mcc_names = RecombTools.name_mcc_clades!(treelist, mccs_naive)
./docs/src/runopt.md:  treelist[i] = RecombTools.reduce_to_mcc(t, mccs_naive)
./docs/src/options.md:The heuristic method used by *RecombTools* tries to prune consistent clades from a pair of trees in order to increase a compatibility score between other clades. 
./docs/src/options.md:using RecombTools # hide
./docs/src/options.md:using RecombTools # hide
./docs/src/mccs.md:*RecombTools* reconstructs the ARG from trees by first inferring Maximally Compatible Clades (MCC). 
./docs/src/mccs.md:using RecombTools
./docs/src/mccs.md:*RecombTools* infers the ARG by finding the branches that are common to both trees. 
./docs/src/mccs.md:using RecombTools # hide
./docs/src/mccs.md:using RecombTools # hide
./docs/src/resolving.md:using RecombTools # hide
./docs/src/resolving.md:using RecombTools
./docs/src/resolving.md:using RecombTools
./docs/src/resolving.md:However, the topology-based heuristic used by *RecombTools* is not able to detect that `X` is the only reassorted leaf *if the trees are not resolved*!
./docs/build/index.html:<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Index · RecombTools documentation</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>RecombTools documentation</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Index</a><ul class="internal"><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li></ul></li><li><span class="tocitem">Usage</span><ul><li><a class="tocitem" href="overview/">Overview</a></li><li><a class="tocitem" href="mccs/">MCCs</a></li><li><a class="tocitem" href="options/">Important options</a></li></ul></li><li><span class="tocitem">Under the hood</span><ul><li><a class="tocitem" href="opttrees/"><code>opttrees</code></a></li><li><a class="tocitem" href="runopt/"><code>runopt</code></a></li><li><a class="tocitem" href="resolving/">Resolving</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="types/">OptArgs</a></li><li><a class="tocitem" href="functions/">Functions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Index</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Index</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PierreBarrat/RecombTools/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="RecombTools"><a class="docs-heading-anchor" href="#RecombTools">RecombTools</a><a id="RecombTools-1"></a><a class="docs-heading-anchor-permalink" href="#RecombTools" title="Permalink"></a></h1><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p><em>RecombTools</em> relies on the non-registered julia package <em>TreeTools</em>, that you have to install first.    After that, simply install <em>RecombTools</em> from the url of this github repo: </p><pre><code class="language-julia hljs">using Pkg
./docs/build/index.html:Pkg.add(url=&quot;https://github.com/PierreBarrat/RecombTools#master&quot;)</code></pre><p>You should now be able to use <code>using RecombTools</code>.  </p><p>To use the CLI (Linux/Mac users), build the package by calling </p><pre><code class="language-julia hljs">Pkg.build(&quot;RecombTools&quot;)</code></pre><p>This will add executable scripts to your <code>~/.julia/bin</code> folder.  Simply add this folder to your path to call the script, <em>e.g.</em> <code>export PATH=&quot;$HOME/.julia/bin:$PATH&quot;</code>.  You should now be able to call, <em>e.g.</em>, <code>recombtools treeknit --help</code></p></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="overview/">Overview »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Tuesday 26 October 2021 17:12">Tuesday 26 October 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
./docs/build/opttrees/index.html:<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>opttrees · RecombTools documentation</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">RecombTools documentation</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Index</a></li><li><span class="tocitem">Usage</span><ul><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../mccs/">MCCs</a></li><li><a class="tocitem" href="../options/">Important options</a></li></ul></li><li><span class="tocitem">Under the hood</span><ul><li class="is-active"><a class="tocitem" href><code>opttrees</code></a><ul class="internal"><li><a class="tocitem" href="#Coarse-graining-of-naive-MCCs"><span>Coarse-graining of naive MCCs</span></a></li><li><a class="tocitem" href="#The-SplitGraph-object"><span>The <code>SplitGraph</code> object</span></a></li><li><a class="tocitem" href="#Counting-incompatibilities"><span>Counting incompatibilities</span></a></li><li><a class="tocitem" href="#Simulated-annealing"><span>Simulated annealing</span></a></li></ul></li><li><a class="tocitem" href="../runopt/"><code>runopt</code></a></li><li><a class="tocitem" href="../resolving/">Resolving</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../types/">OptArgs</a></li><li><a class="tocitem" href="../functions/">Functions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Under the hood</a></li><li class="is-active"><a href><code>opttrees</code></a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href><code>opttrees</code></a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PierreBarrat/RecombTools/blob/master/docs/src/opttrees.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="opttrees"><a class="docs-heading-anchor" href="#opttrees">The <code>opttrees</code> function</a><a id="opttrees-1"></a><a class="docs-heading-anchor-permalink" href="#opttrees" title="Permalink"></a></h1><p>The core of the heuristic <em>RecombTools</em> is based on happens in the <code>opttrees</code> function, found in the <code>SplitGraph</code> submodule.    Given two trees, <code>opttrees</code> attempts to reconcile them by pruning certain clades.    A quick description of different steps in this function is given here, with the two simple trees below as an example case: </p><pre><code class="language-julia hljs">nwk1 = &quot;(((A1:1,A2:2):2,(B1:2,(B2:1,B3:1):1):2):2,(C1:1,C2:2):4)&quot;;
./docs/build/opttrees/index.html: [&quot;B1&quot;, &quot;B2&quot;, &quot;B3&quot;]</code></pre><p>Trees are then &quot;reduced&quot; to those MCCs: new trees are built where each leaf corresponds to one of the naive MCCs.    The reduced trees have incompatibilities at the leaf level: it is no longer possible to group some of their leaves together in a consistent clade.  </p><pre><code class="language-julia hljs">mcc_names = RecombTools.name_mcc_clades!(treelist, mcc)
./docs/build/opttrees/index.html:	treelist[i] = RecombTools.reduce_to_mcc(t, mcc)
./docs/build/opttrees/index.html:  &quot;MCC_1&quot; =&gt; [&quot;A1&quot;, &quot;A2&quot;]</code></pre><h2 id="The-SplitGraph-object"><a class="docs-heading-anchor" href="#The-SplitGraph-object">The <code>SplitGraph</code> object</a><a id="The-SplitGraph-object-1"></a><a class="docs-heading-anchor-permalink" href="#The-SplitGraph-object" title="Permalink"></a></h2><p>Once the trees reduced to their naive MCCs, we construct a <code>SplitGraph</code> object from them. </p><div class="admonition is-info"><header class="admonition-header">*SplitGraph* submodule</header><div class="admonition-body"><p>The <code>SplitGraph</code> type and some of the functions used below are in the <em>SplitGraph</em> submodule of <em>RecombTools</em>. Access them by calling <code>using RecombTools.SplitGraph</code> and preceding the calls by <code>SplitGraph.</code></p></div></div><p>The <code>SplitGraph</code> is a directed graph that is based on both trees, and has two kind of nodes: </p><ul><li>leaf nodes correspond to leaves of the trees, and are identifier by integers.  They have as many ancestors as there are trees in the <code>SplitGraph</code>. </li><li>internal nodes, called <code>SplitNode</code>s, correspond to internal nodes in one of the two trees. A <code>color::Int</code> attribute identifies the tree to which they belong (<em>e.g.</em> 1 for the first tree, 2 for the second, etc...). They have only one ancestor, of the same color.  Importantly, they are identified by the ensemble of leaf nodes that are &quot;below&quot; them, that is the subset of all their direct and indirect offsprings that are leaves.  As such, they uniquely correspond to a split in one of the two trees.  This information is stored as an array of integer in their <code>conf</code> field. </li></ul><p>Let us know build the <code>SplitGraph</code> object: </p><pre><code class="language-julia hljs">using RecombTools.SplitGraph
./docs/build/search_index.js:[{"location":"functions/","page":"Functions","title":"Functions","text":"CurrentModule = RecombTools\nDocTestSetup  = quote\n    using TreeTools\nend\t","category":"page"},{"location":"functions/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Pages = [\"functions.md\"]","category":"page"},{"location":"functions/#Computing-Maximal-Compatible-Clades-(MCCs)-for-a-set-of-trees","page":"Functions","title":"Computing Maximal Compatible Clades (MCCs) for a set of trees","text":"","category":"section"},{"location":"functions/#Main-functions","page":"Functions","title":"Main functions","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"computeMCCs\ncomputeMCCs!","category":"page"},{"location":"functions/#RecombTools.computeMCCs","page":"Functions","title":"RecombTools.computeMCCs","text":"computeMCCs(\n\tt1::Tree, t2::Tree, oa::OptArgs = OptArgs();\n\tpreresolve = false, naive = false, seqlengths = [1,1],\n)\ncomputeMCCs(\n\ttrees::Dict, oa::OptArgs=OptArgs();\n\tpreresolve = false, naive = false, seqlengths = Dict(s=>1 for s in keys(trees)),\n)\n\nCompute pairwise MCCs for trees. Return MCCs and resolved splits. The computeMCCs! version resolves the input trees with newly found splits.\n\nInputs\n\noa::OptArgs\n\nControls parameters of the MCC inference (unless naive=true). See ?OptArgs for details.\n\npreresolve = false\n\nIf true, a first pass of MCC computation is made and trees are resolved using the results, keeping only compatible splits if more than two trees are given as input. A second pass of MCC computation is then made without resolving.\nElse, only the first pass is performed. For more than two trees, this may find MCCs that introduce incompatible splits in case of poorly resolved input trees.\n\nIn general, this should be set to true if more than two trees are used, and to false   for only two trees (for speed).\n\nnaive = false\n\nIf true, use a naive estimation for MCCs, i.e. find all clades that have an exactly matching topology in all trees.\nElse, use a pseudo-parsimonious method based (mostly) on topology. The method runopt(oa,t1,t2) is called on every pair of trees.\n\n\n\n\n\n","category":"function"},{"location":"functions/#RecombTools.computeMCCs!","page":"Functions","title":"RecombTools.computeMCCs!","text":"computeMCCs!(\n\ttrees::Dict, oa::OptArgs=OptArgs();\n\tpreresolve = false, naive = false, seqlengths = Dict(s=>1 for s in keys(trees)),\n)\n\nSee computeMCCs.\n\n\n\n\n\n","category":"function"},{"location":"functions/#For-pairs-of-trees-only","page":"Functions","title":"For pairs of trees only","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"naive_mccs\nRecombTools.runopt","category":"page"},{"location":"functions/#RecombTools.naive_mccs","page":"Functions","title":"RecombTools.naive_mccs","text":"naive_mccs(treelist)\n\nFind sets of nodes which are:\n\nclades in all trees of treelist,\nall subclades of nodes are clades in all trees of treelist (both of these properties define consistency),\nmaximal: adding a node to a set results it in not being a clade in at least one of the trees.\n\nAll the trees of treelist should share the same leaf nodes.\n\n\n\n\n\n","category":"function"},{"location":"functions/#RecombTools.runopt","page":"Functions","title":"RecombTools.runopt","text":"\trunopt(t1::Tree, t2::Tree; kwargs...)\n\trunopt(oa::OptArgs, t1::Tree, t2::Tree)\n\trunopt(oa::OptArgs, trees::Dict{<:Any,<:Tree})\n\nRun optimization at constant γ. See ?Optargs for arguments. In the first form, keyword   arguments are given to OptArgs.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Resolving-trees","page":"Functions","title":"Resolving trees","text":"","category":"section"},{"location":"functions/#Using-topology","page":"Functions","title":"Using topology","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"resolve!(::TreeTools.Tree, ::TreeTools.Tree)","category":"page"},{"location":"functions/#RecombTools.resolve!-Tuple{TreeTools.Tree, TreeTools.Tree}","page":"Functions","title":"RecombTools.resolve!","text":"resolve!(t1::Tree, t2::Tree; tau=0.)\n\nResolve t1 using splits of t2 and inversely. Every split of t2 a tree that is compatible with t1 is introduced in t1 with branch length tau (and inversely). Return new splits in each tree.\n\n\n\n\n\n","category":"method"},{"location":"mccs/#Maximally-Compatible-Clades","page":"MCCs","title":"Maximally Compatible Clades","text":"","category":"section"},{"location":"mccs/","page":"MCCs","title":"MCCs","text":"RecombTools reconstructs the ARG from trees by first inferring Maximally Compatible Clades (MCC). ","category":"page"},{"location":"mccs/#Handling-trees","page":"MCCs","title":"Handling trees","text":"","category":"section"},{"location":"mccs/","page":"MCCs","title":"MCCs","text":"Functions that directly handle trees are found in the separate TreeTools package.    Here is a short list of useful ones: ","category":"page"},{"location":"mccs/","page":"MCCs","title":"MCCs","text":"read_tree(file): read tree from newick file, return Tree object. \nparse_newick(string): parse newick string into a TreeNode object.\nnode2tree(n::TreeNode): create a Tree object from node n, using it as a root. \nwrite_newick(file::String, t::Tree)/write_newick([file::String], n::TreeNode): write tree to file using newick format. Return a newick string if file is not provided. ","category":"page"},{"location":"mccs/#Simple-case","page":"MCCs","title":"Simple case","text":"","category":"section"},{"location":"mccs/","page":"MCCs","title":"MCCs","text":"Let's see how to infer Maximally Compatible Clades (MCC) for a very simple case: two trees with five leaves. ","category":"page"},{"location":"mccs/","page":"MCCs","title":"MCCs","text":"using RecombTools\nt1 = node2tree(parse_newick(\"((A,B),(C,(D,X)))\"))\nt2 = node2tree(parse_newick(\"((A,(B,X)),(C,D))\"))","category":"page"},{"location":"mccs/","page":"MCCs","title":"MCCs","text":"The computeMCCs function takes two trees as input. ","category":"page"},{"location":"mccs/","page":"MCCs","title":"MCCs","text":"mccs = computeMCCs(t1, t2)","category":"page"},{"location":"mccs/","page":"MCCs","title":"MCCs","text":"Individual MCCs are simply arrays containing labels of leaves of the trees.  ","category":"page"},{"location":"mccs/#Interpretation-of-results","page":"MCCs","title":"Interpretation of results","text":"","category":"section"},{"location":"mccs/","page":"MCCs","title":"MCCs","text":"The genealogy of two RNA segments subject to reassortment is described by an Ancestral Reassortment Graph (ARG).  An ARG is a directed graph that represents the lineage of a given pair of segments by coalescence of nodes, as in a genealogical tree, but also shows reassortment events and the exchange of segments by nodes that have two ancestors.  Since reassortments only occur between segments, the genealogy of given segment is described by a tree.  As a result, the ARG must embed both segment-trees, and every branch in the ARG has to belong to either one of the trees, or to both. ","category":"page"},{"location":"mccs/","page":"MCCs","title":"MCCs","text":"RecombTools infers the ARG by finding the branches that are common to both trees.  Given two trees with potentially different topologies, it tries to \"glue\" them together in a reasonable way, where the interpretation of reasonable can vary between parsimonious and conservative (see the parsimony parameter gamma). ","category":"page"},{"location":"mccs/","page":"MCCs","title":"MCCs","text":"The MCCs returned by computeMCCs represent regions of the ARG (and of the segment trees) where branches are common to both trees.  In other words, these are the regions where the two segment trees must be \"glued together\".  Given those regions and the knowledge of the trees, it is possible to unambiguously reconstruct the genealogy. ","category":"page"},{"location":"mccs/","page":"MCCs","title":"MCCs","text":"info: Number of reassortments in the genealogy\nWhen going up the ARG (backwards in time), a reassortment consists of passing from a region where branches are common to the two trees to a region where they are not. It is a split of branches.  As a consequence, the root of each MCC must be a reassortment, with the exception of an MCC containing the root of both trees.  The number of reassortments events in the inferred ARG can thus simply be obtained by counting the number of MCCs, potentially removing the one that contains the roots of both trees if it exists. ","category":"page"},{"location":"mccs/#More-than-two-trees","page":"MCCs","title":"More than two trees","text":"","category":"section"},{"location":"mccs/","page":"MCCs","title":"MCCs","text":"If more than two trees are given as input, computeMCCs infers MCCs for all pairs of trees.   Use a Dict to pass the trees as input. ","category":"page"},{"location":"mccs/","page":"MCCs","title":"MCCs","text":"using RecombTools # hide\nt1 = node2tree(parse_newick(\"((A,B),((C,Y),(D,X)))\"))\nt2 = node2tree(parse_newick(\"((A,(B,X)),((C,Y),D))\"))\nt3 = node2tree(parse_newick(\"((A,(B,Y)),(C,(D,X)))\"))\ntrees = Dict(1=>t1, 2=>t2, 3=>t3)\nmccs = computeMCCs(trees)\nmccs[1,2] # MCCs for t1 and t2","category":"page"},{"location":"mccs/","page":"MCCs","title":"MCCs","text":"mccs[1,3] # MCCs for t1 and t3","category":"page"},{"location":"mccs/","page":"MCCs","title":"MCCs","text":"The output mccs is also a Dict, indexed by pairs of keys of the input dictionary trees.  Indexing is symmetric: mccs[i,j] == mccs[j,i].  By convention, mccs[i,i] exists and is empty. ","category":"page"},{"location":"mccs/#naive_mccs","page":"MCCs","title":"Naive estimation","text":"","category":"section"},{"location":"mccs/","page":"MCCs","title":"MCCs","text":"It is also possible to compute a \"naive\" estimation of MCCs using the naive keyword.    When naive is set to true, computeMCCs returns maximum clades that are exactly compatible between pairs of trees: ","category":"page"},{"location":"mccs/","page":"MCCs","title":"MCCs","text":"using RecombTools # hide\nt1 = node2tree(parse_newick(\"(((A1,A2),(B1,B2)),(C1,C2))\"))\nt2 = node2tree(parse_newick(\"(((A1,A2),(C1,C2)),(B1,B2))\"))\ntrees = Dict(1=>t1, 2=>t2)\ncomputeMCCs(trees; naive=true)","category":"page"},{"location":"opttrees/#opttrees","page":"opttrees","title":"The opttrees function","text":"","category":"section"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"The core of the heuristic RecombTools is based on happens in the opttrees function, found in the SplitGraph submodule.    Given two trees, opttrees attempts to reconcile them by pruning certain clades.    A quick description of different steps in this function is given here, with the two simple trees below as an example case: ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"using RecombTools# hide\nnwk1 = \"(((A1:1,A2:2):2,(B1:2,(B2:1,B3:1):1):2):2,(C1:1,C2:2):4)\";\nnwk2 = \"((A1:1,A2:2):2,((B1:2,(B2:1,B3:1):1):1,(C1:1,C2:2):1):1)\";\nt1 = node2tree(parse_newick(nwk1))\nt2 = node2tree(parse_newick(nwk2))\nnothing # hide","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"Trees are not displayed here for space reasons, but you're encouraged to draw them if you want to follow along! ","category":"page"},{"location":"opttrees/#Coarse-graining-of-naive-MCCs","page":"opttrees","title":"Coarse-graining of naive MCCs","text":"","category":"section"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"As a first step, naive MCCs are computed for input trees using the naive_mccs function.    Here, we find three clades that are already compatible between the two trees: ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"treelist = Any[t1, t2]\nmcc = naive_mccs(treelist)","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"Trees are then \"reduced\" to those MCCs: new trees are built where each leaf corresponds to one of the naive MCCs.    The reduced trees have incompatibilities at the leaf level: it is no longer possible to group some of their leaves together in a consistent clade.  ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"mcc_names = RecombTools.name_mcc_clades!(treelist, mcc)\nfor (i,t) in enumerate(treelist)\n\ttreelist[i] = RecombTools.reduce_to_mcc(t, mcc)\nend\nnothing # hide","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"The trees in treelist are now a reduced form of t1 and t2, and the names of the new leaves correspond to clades in the original tree.    The mapping between leaf name and original clade is stored in mcc_names","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"treelist[1]\ntreelist[2]\nmcc_names","category":"page"},{"location":"opttrees/#The-SplitGraph-object","page":"opttrees","title":"The SplitGraph object","text":"","category":"section"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"Once the trees reduced to their naive MCCs, we construct a SplitGraph object from them. ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"info: *SplitGraph* submodule\nThe SplitGraph type and some of the functions used below are in the SplitGraph submodule of RecombTools. Access them by calling using RecombTools.SplitGraph and preceding the calls by SplitGraph.","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"The SplitGraph is a directed graph that is based on both trees, and has two kind of nodes: ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"leaf nodes correspond to leaves of the trees, and are identifier by integers.  They have as many ancestors as there are trees in the SplitGraph. \ninternal nodes, called SplitNodes, correspond to internal nodes in one of the two trees. A color::Int attribute identifies the tree to which they belong (e.g. 1 for the first tree, 2 for the second, etc...). They have only one ancestor, of the same color.  Importantly, they are identified by the ensemble of leaf nodes that are \"below\" them, that is the subset of all their direct and indirect offsprings that are leaves.  As such, they uniquely correspond to a split in one of the two trees.  This information is stored as an array of integer in their conf field. ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"Let us know build the SplitGraph object: ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"using RecombTools.SplitGraph\ng = SplitGraph.trees2graph(treelist); \ng.labels_to_int","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"warning: Warning\nIt is recommemded that you add ; to the end of lines when working with SplitGraph, SplitNode or LeafNode in the REPL.  If you forget, you will quickly see why :-) ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"We now see that the three leaves from our coarse-grained trees have been attributed an integer index in the SplitGraph.    Let us take a look at the internal nodes above the leaf MCC_3: ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"a1 = g.leaves[g.labels_to_int[\"MCC_3\"]].anc[1]; # Ancestor for the first tree\na2 = g.leaves[g.labels_to_int[\"MCC_3\"]].anc[2]; # Ancestor for the second tree\n[a1.color, a2.color] # a1 and a2 resp. belong to trees 1 and 2\na1.conf # list of leaves below `a1`. Among those is the index for \"MCC_3\".\n[g.labels[i] for i in a1.conf] # Same as above, with labels\n[g.labels[i] for i in a2.conf] # and the same for a2 ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"We now immediatly see that the internal nodes above MCC_3 in the two trees define different splits: (MCC_1, MCC_3) in the first tree is different from (MCC_2, MCC_3) in the second tree.    This is the idea underlying the inference of MCCs. ","category":"page"},{"location":"opttrees/#Counting-incompatibilities","page":"opttrees","title":"Counting incompatibilities","text":"","category":"section"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"In the example above, the ancestors of leaf MCC_3 in the two trees define different splits: this is called an incompatibility.    Examination of the trees reveals that there are also similar incompatibilitie for the two other leaves MCC_1 and MCC_2.    This can be computed using the count_mismatches function: ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"SplitGraph.count_mismatches(g)","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"We indeed find 3 mismatches, one for each leaf. ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"However, it is possible to explain the two example trees using less than three reassortments.    What would happen for example if we removed MCC_1 from both trees?    The first non-trivial split above leaf MCC_3 in both trees would then be (MCC_2, MCC_3), and the same goes for leaf MCC_2.    The number of incompatibilities would then go down to 0.  \"Removing\" leaves from the trees, or the graph, is done by defining a configuration: an array of booleans that stores the presence or absence of each leaf.    To remove MCC_1, we simply design a configuration that has 0 at the index corresponding to MCC_1: ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"  conf = ones(Bool, length(g.leaves))\n  conf[g.labels_to_int[\"MCC_1\"]] = false # Remove `MCC_3` from the configuration\n  conf","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"To compute the number of incompatibilities given a configuration, we use the compute_energy function. The result is interpreted as the \"energy\" of this configuration given the graph g: ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"SplitGraph.compute_energy(conf, g)","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"info: Info\nThe function count_mismatches(g) shown above is a simple shortcut for conf = ones(Bool, length(g.leaves))\nSplitGraph.compute_energy(conf, g)In other words, it computes the energy for the configuration where all leaves are present. ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"By removing a leaf, i.e. by \"enforcing\" a reassortment right above it, we've reduced the number of incompatibilities for the remaining ones to 0.    Since removing a leaf corresponds to \"enforcing\" a reassortment, we have to assign a cost to it, that we call gamma.    This defines a score for each configuration, defined as the difference between the energy of the configuration and gamma times the number of leaves that were removed. Depending on the value of gamma, the difference in overall score associated to removing a leaf or keeping it will change from negative to positive.    Scores are computed with the compute_F function that takes gamma as its last argument.   Here are the differences in scores before and after removing MCC_3, for different values of gamma:   ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"conf0 = ones(Bool, length(g.leaves)) # Configuration with all leaves\nSplitGraph.compute_F(conf, g, 1) - SplitGraph.compute_F(conf0, g, 1)\nSplitGraph.compute_F(conf, g, 2) - SplitGraph.compute_F(conf0, g, 2)\nSplitGraph.compute_F(conf, g, 3) - SplitGraph.compute_F(conf0, g, 3)\nSplitGraph.compute_F(conf, g, 4) - SplitGraph.compute_F(conf0, g, 4)","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"For this simple example, gamma = 3 is the \"critical\" value above which the fact of removing MCC_3 or any other leaf is not considered a good move.    The inference of MCCs for gamma leq 3 and gamma  3 will thus give different results.    In the first case, two MCCs will be found, corresponding to one reassortment event (above MCC_3 for instance) .    In the second, three MCCs and three reassortments will be found. ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"trees = Dict(1=>t1, 2=>t2);\ncomputeMCCs(trees, OptArgs(γ=3.1))[1,2]\ncomputeMCCs(trees, OptArgs(γ=2.9))[1,2]","category":"page"},{"location":"opttrees/#Simulated-annealing","page":"opttrees","title":"Simulated annealing","text":"","category":"section"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"The opttrees function attempts to find the configuration, i.e. a set of leaves to remove, that minimizes the compatibility score presented above.    Since this is a discrete optimization problem with no clear mathematical formalization, we choose to use the simulated annealing technique.  Let us find optimum configurations for our simple trees: ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"Trange = reverse(1e-3:1e-2:1) # Cooling schedule\nM = 10 # Number of iterations per temperature value\nopt_confs = SplitGraph.sa_opt(g; Trange, M, γ = 2)[1]","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"We find three optimal configurations, each corresponding to removing one leaf.    This indeed corresponds to the three possible single-reassortment explanations that we could give to reconcile the two trees.    Without branch length information, it is impossible to choose between one of these three optimas: the problem is degenerate.    A likelihood based way to break this degeneracy using branch length is described here.","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"For now, let's imagine that we have chosen the first optimum configuration as our best solution.    Let's now map it back on the initial trees: ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"removed_leaves = g.labels[.!opt_confs[1]] # Expressed with coarse grained leaves\n# `mcc_names` was defined above\nremoved_clades = [mcc_names[x] for x in removed_leaves]","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"What this means is that we have just inferred all elements in removed_clades (just one in our case) to be MCCs.    Of course, in this simple example, it is immediate to see that the other MCC simply consists of all the remaining leaves in the original trees.    This can also be deduced from the fact that the energy of all the optimal configurations is 0.  However, in the general case, some incompatibilities will remain even after simulated annealing.    For this reason, the opttrees function only outputs MCCs that have been identified by having removed them from the tree, i.e. by having enforced a reassortment above their root node.    If the trees that remain after having pruned these MCCs still have incompatibilities, the process described here needs to be iterated.    This is performed by the runopt function. ","category":"page"},{"location":"flu_example/#Flu-example","page":"Flu example","title":"Flu example","text":"","category":"section"},{"location":"flu_example/","page":"Flu example","title":"Flu example","text":"RecombTools includes the small submodule Flu that contains convenient functions when working with influenza trees.    To infer MCCs from a pair of influenza trees, we first use the Flu.read_flu_trees function that takes a dictionary pointing to newick files as input: ","category":"page"},{"location":"flu_example/","page":"Flu example","title":"Flu example","text":"using RecombTools\ntree_files = Dict(\n\t\"ha\" => dirname(pathof(RecombTools)) * \"/../examples/tree_h3n2_ha_2013-09.nwk\",\n\t\"na\" => dirname(pathof(RecombTools)) * \"/../examples/tree_h3n2_na_2013-09.nwk\"\n)\nflutrees = Flu.read_flu_trees(tree_files)","category":"page"},{"location":"flu_example/","page":"Flu example","title":"Flu example","text":"read_flu_trees does two things: ","category":"page"},{"location":"flu_example/","page":"Flu example","title":"Flu example","text":"read input trees and store them in a Dict{String, Tree}, which is the input format of computeMCCs\nremove \"short\" branches from the trees.  Some tree builders introduce branches of insignificant length in trees to make them binary, which conflicts with the topological approach used by RecombTools.  It is necessary to remove these branches.  The threshold below which a branch is removed is frac12L where L is the length of the gene sequence. ","category":"page"},{"location":"flu_example/","page":"Flu example","title":"Flu example","text":"We can now simply infer MCCs for these trees:","category":"page"},{"location":"flu_example/","page":"Flu example","title":"Flu example","text":"computeMCCs(flutrees)[\"ha\", \"na\"]","category":"page"},{"location":"overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"RecombTools offers a simple CLI script: treeknit.  In short, it takes two trees as input, passed as Newick files, and returns an Ancestral Reassortment Graph. ","category":"page"},{"location":"overview/#Input","page":"Overview","title":"Input","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Inputs to treeknit are two files containing trees in Newick format.  The only strict condition on the trees is that they share their leaf nodes.  Example: ","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"recombtools treeknit tree1.nwk tree2.nwk","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"warning: Insignificant branches\nTree builders sometimes introduce branches of insignificant length in order to resolve polytomies and obtain binary trees. Since RecombTools relies on topological differences between trees, it is important to remove these branches prior to passing the trees to treeknit. This can be done by using only branches with high bootstrap value (typically, 75), or by removing branches shorter than, e.g., (L2)^-1, where L is the length of the sequences. ","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"warning: Rooting the trees\nThe result RecombTools depend how the trees are rooted. It is important that the two trees are rooted in a consistent way. We recommend using the same outgroup for rooting both trees.","category":"page"},{"location":"overview/#Output","page":"Overview","title":"Output","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Output of the inference is written a directory called treeknit_results. This can be changed using the --outdir option.    The directory will contain:   ","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"the ARG, written as an extended Newick string.   \nthe MCCs, i.e. shared regions of the trees, indicated by the leaves they contain.  \nresolved trees, where polytomies have been reduced as much as possible using the knowledge of the MCCs.   \na table with the correspondence between internal nodes of the ARG and the trees. Note that this refers to node labels of the resolved trees, which may not be the same as the ones given as input.   ","category":"page"},{"location":"overview/#Options","page":"Overview","title":"Options","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"The main options that you can play with are:  ","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"the parsimony parameter gamma, --gamma or -g.   \nnaive inference --naive. Using this flag is equivalent to setting gamma rightarrow infty.  \nLength of sequences used to infer trees: --seq-lengths. These are used for likelihood test to break degeneracy between topologically equivalent MCCs.  ","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"More details in the options section.","category":"page"},{"location":"options/#options","page":"Important options","title":"Options","text":"","category":"section"},{"location":"options/","page":"Important options","title":"Important options","text":"computeMCCs uses a topogy based heuristic optimization to find maximally compatible clades.    Options to this heuristic are provided through the OptArgs object, that is optionally passed as a second argument.   Essential options are detailed here. \t","category":"page"},{"location":"options/#gamma","page":"Important options","title":"Parsimony parameter","text":"","category":"section"},{"location":"options/","page":"Important options","title":"Important options","text":"The heuristic method used by RecombTools tries to prune consistent clades from a pair of trees in order to increase a compatibility score between other clades.    Pruning a clade is interpreted as fixing a reassortment right above it, while increasing the compatibility between remaining clades removes reassortments.    A purely parsimonious heuristic should thus give the same weight to fixing a reassortment through pruning a clade and fixing one incompatibility in the trees. ","category":"page"},{"location":"options/","page":"Important options","title":"Important options","text":"Here, we assign the score gamma to each pruned clade, and count as 1 each incompatibility fixed for the remaining clades.    For gamma=1, we obtain a parsimonious method that attempts to minimize the overall number of reassortments.    For higher values, pruning a clade must \"fix\" at least gamma incompatibilities to be considered a good move, making the obtained MCCs less parsimonious.    For infinite gamma, pruning clades is impossible, and we fall back on the naive estimation of MCCs. ","category":"page"},{"location":"options/","page":"Important options","title":"Important options","text":"The example below illustrates the difference between different gamma values: ","category":"page"},{"location":"options/","page":"Important options","title":"Important options","text":"using RecombTools # hide\nt1 = node2tree(parse_newick(\"((((A,B),C),D),E)\"))\nt2 = node2tree(parse_newick(\"((((D,B),E),A),C)\")) # Same topology, but shuffled leaves\ntrees = Dict(1=>t1, 2=>t2)\nnothing # hide","category":"page"},{"location":"options/","page":"Important options","title":"Important options","text":"Here, pruning the two leaves (A,C) or (D,E) results in compatible trees (resp. ((B,D),E) and ((A,B),C)).    These moves each have a cost 2gamma (removing 2 clades), but bring us from trees with 5 incompatibilities to 0.    They will only be accepted if gamma leq 25. ","category":"page"},{"location":"options/","page":"Important options","title":"Important options","text":"  computeMCCs(trees, OptArgs(γ=2))[1,2]\n  computeMCCs(trees, OptArgs(γ=3))[1,2]","category":"page"},{"location":"options/#Resolving-trees-with-polytomies","page":"Important options","title":"Resolving trees with polytomies","text":"","category":"section"},{"location":"options/","page":"Important options","title":"Important options","text":"See Resolving","category":"page"},{"location":"options/#likelihood","page":"Important options","title":"Degeneracy: sorting with likelihood","text":"","category":"section"},{"location":"options/","page":"Important options","title":"Important options","text":"When several MCC decompositions are possible, degeneracy is removed by using the likelihood_sort option (activated by default).  In the example below, there are three equivalent decompositions if only topology is considered: ","category":"page"},{"location":"options/","page":"Important options","title":"Important options","text":"using RecombTools # hide\nt1 = node2tree(parse_newick(\"((A:2,B:2):2,C:4)\"))\nt2 = node2tree(parse_newick(\"(A:2,(B:1,C:1):1)\"))\ntrees = Dict(1=>t1, 2=>t2)\noa = OptArgs(likelihood_sort = false)\nunique([computeMCCs(trees, oa)[1,2] for rep in 1:50]) # Repeating computation many times ","category":"page"},{"location":"options/","page":"Important options","title":"Important options","text":"When taking branch lengths into account, this degeneracy vanishes: ","category":"page"},{"location":"options/","page":"Important options","title":"Important options","text":"oa = OptArgs(likelihood_sort = true)\nunique([computeMCCs(trees, oa)[1,2] for rep in 1:50])","category":"page"},{"location":"runopt/#The-runopt-function","page":"runopt","title":"The runopt function","text":"","category":"section"},{"location":"runopt/","page":"runopt","title":"runopt","text":"using RecombTools\nusing RecombTools.SplitGraph\nusing TreeTools","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"For larger trees, opttrees will not find all reassortments at once.    The reason for this is that it is often necessary to \"clean\" reassorted leaves in smaller clades in order to see other reassortments deeper in the tree.    As a consequence, trees obtained after one round of opttrees will still have incompatibilities.  Below is a relatively simple example of trees for which opttrees does not find all reassorted leaves in one go: ","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"nwk1 = \"(Z,(G,(((A,X),(B,C)),((D,Y),(E,F)))))\"\nnwk2 = \"(G,((A,(B,(C,X))),((D,(E,(F,Y))),Z)))\"\nt1 = node2tree(parse_newick(nwk1))\nt2 = node2tree(parse_newick(nwk2))\nnothing # hide","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"These trees are constructed in the following way (you're encouraged to draw them!): ","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"Clade ((A,X),(B,C)) in the first tree \"corresponds\" to clade (A,(B,(C,X))) in the second tree, with X as the reassorted leaf.  Same goes for clades ((D,Y),(E,F)) and (D,(E,(F,Y))). \nWe respectively name these not yet compatible clades ABC and DEF. At a deeper level, the trees are now of the form (Z,(G,(ABC,DEF))) for the first and (G,(ABC,(DEF,Z))) for the second, with Z as the obvious reassorted leaf. ","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"The important property here is that for a high enough value of gamma, it is only possible for opttrees to see that Z is reassorted if clades ABC and DEF are \"coarse-grained\" to leaves.    In return, this coarse-graining is only possible after X and Y have been identified as reassorted leaves, which will happen after a first iteration of opttrees.     The task of iterating opttrees is performed by the runopt function.    Here, we walk through typical steps it takes.","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"Let's do a first pass with opttrees, with gamma=3.     We first build the SplitGraph object, as detailed in the opttrees page. ","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"treelist = Any[t1, t2]\nmccs_naive = naive_mccs(treelist) # these are just the leaves in this example\nmcc_names = RecombTools.name_mcc_clades!(treelist, mccs_naive)\nfor (i,t) in enumerate(treelist)\n  treelist[i] = RecombTools.reduce_to_mcc(t, mccs_naive)\nend\ng = SplitGraph.trees2graph(treelist);\nnothing # hide","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"We then run the simulated annealing optimization to find optimal leaves to remove. ","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"opt_confs = SplitGraph.sa_opt(g; Trange = reverse(1e-3:1e-2:1), M = 10, γ = 3)[1]\nmccs_found = [mcc_names[x] for x in g.labels[.!opt_confs[1]]]","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"!!! info gamma = 2     If you run this example using gamma leq 2, Z will immediatly be found as a reassorted strain.      It is indeed not easy to find example that combine trees with a small number of leaves (9 here), obvious reassortments, and that are not solved in one go by opttrees with a low value of gamma.      However, when dealing with trees with hundreds of leaves, finding all MCCs in one go is the exception rather than the rule. ","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"As expected, X Y are found as reassortants.    However, the two trees will still have incompatibilities when removing those two leaves.    To make this explicit, we remove the leaves X and Y and compute naive mccs again. ","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"RecombTools.pruneconf!(mccs_found, treelist...) # prune clades in a list of trees. Wrapper around TreeTools.prunesutree!\nmccs_naive = naive_mccs(treelist...)","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"Now that X and Y are removed, we see that clades ABC and DEF are common to both trees.    If we reduce the pruned trees to their new naive MCCs again, we now see that Z is an obvious choice for a reassorted strain: ","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"mcc_names = RecombTools.name_mcc_clades!(treelist, mccs_naive)\nfor (i,t) in enumerate(treelist)\n  treelist[i] = RecombTools.reduce_to_mcc(t, mccs_naive)\nend\ntreelist[1]\ntreelist[2]","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"To finish the inference of MCCs, we would now have to re-run the optimization process.    It is now clear that the opttrees has to be iterated.    This is performed automatically by the runopt function.    This process stops when one of the following end conditions is found: ","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"If no new MCCs are found in a given iteration of opttrees.  This occurs when the optimal configuration resulting from the simulated annealing has all leaves present. \nIf not and new MCCs were found, prune them from the trees.  If the resulting trees do not have any incompatibility.\nIf not, if the maximum number of iterations has been reached.  This can be set through OptArgs, with a default of 15. ","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"","category":"page"},{"location":"#RecombTools","page":"Index","title":"RecombTools","text":"","category":"section"},{"location":"#Installation","page":"Index","title":"Installation","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"RecombTools relies on the non-registered julia package TreeTools, that you have to install first.    After that, simply install RecombTools from the url of this github repo: ","category":"page"},{"location":"","page":"Index","title":"Index","text":"using Pkg\nPkg.add(url=\"https://github.com/PierreBarrat/TreeTools#master\")\nPkg.add(url=\"https://github.com/PierreBarrat/RecombTools#master\")","category":"page"},{"location":"","page":"Index","title":"Index","text":"You should now be able to use using RecombTools.  ","category":"page"},{"location":"","page":"Index","title":"Index","text":"To use the CLI (Linux/Mac users), build the package by calling ","category":"page"},{"location":"","page":"Index","title":"Index","text":"Pkg.build(\"RecombTools\")","category":"page"},{"location":"","page":"Index","title":"Index","text":"This will add executable scripts to your ~/.julia/bin folder.  Simply add this folder to your path to call the script, e.g. export PATH=\"$HOME/.julia/bin:$PATH\".  You should now be able to call, e.g., recombtools treeknit --help","category":"page"},{"location":"resolving/#Resolving","page":"Resolving","title":"Resolving","text":"","category":"section"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"The lack of resolution in the inference of phylogenetic trees results in polytomies: internal nodes with more than two offsprings.    Polytomies can cause the topology of two trees to differ, which cause problems when inferring reassortments using topological information.    Suppose for instance that we have a first tree (e.g. for a given segment of flu): ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"using RecombTools # hide\nt1 = node2tree(parse_newick(\"(A,(B,C))\"))","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"where we can identify the clade (B,C) because of a mutation in this segment present in B and C but not in A. ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"If this mutation does not exist in a second segment, then in the absence of reassortment its tree will look something like this: ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"t2 = node2tree(parse_newick(\"(A,B,C)\"))","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"As a result, t1 and t2 differ for a reason unrelated with reassortment. ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"To overcome this issue, one has to resolve trees as much as possible, typically using the information of one to remove polytomies in the other.    This can only be done if no reassortments are present. ","category":"page"},{"location":"resolving/#Resolving-pairs-of-trees","page":"Resolving","title":"Resolving pairs of trees","text":"","category":"section"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"In the example above, it is natural to think that the difference between the two trees is due to a lack of resolution and not to reassortment.    This is because the split (B,C) in the first tree is compatible with the second tree: it is possible to add this split to t2.    What this means is that the difference in topology can be explained by something else than reassortment. ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"In this case, we can simply resolve t2 by adding each split in t1 with which it is compatible.    If t1 has polytomies, the same could be done to resolve t1 using t2.    This operation is performed by the resolve! function: ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"using RecombTools\nt1 = node2tree(parse_newick(\"(A,(B,C))\"))\nt2 = node2tree(parse_newick(\"(A,B,C)\"))","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"new_splits = resolve!(t1, t2);\nt2","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"resolve! returns an array of SplitList objects (of the TreeTools package) containing the new splits introduced in each of the two trees: ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"isempty(new_splits[1])\nnew_splits[2]","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"If the resolve option is passed to computeMCCs (through OptArgs), resolve! will be called on each pair of trees before each iteration of the MCC inference procedure. ","category":"page"},{"location":"resolving/#Resolving-during-MCC-inference","page":"Resolving","title":"Resolving during MCC inference","text":"","category":"section"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"The above resolving method works fine for simple \"obvious\" cases, where a split in one tree directly resolves a polytomy in another.  However, consider the following case: ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"using RecombTools","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"t1 = node2tree(parse_newick(\"((A,B),(C,(D,(E,X))))\"))\nt2 = node2tree(parse_newick(\"((A,(B,X)),(C,D,E))\"))","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"There are now two sources of topological differences between t1 and t2: ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"The reassorted strain X. \nThe lack of resolution resulted in a polytomy (C,D,E) in t2, which is resolved in t1 in the form of (C,(D,(E,X)) ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"The resolve! function is helpless in such cases: ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"new_splits = resolve!(t1, t2)\nisempty(new_splits[2])","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"Indeed, there is no split in t1 that can directly help us resolve t2.    The closest such split is (D,E,X), but it is incompatible with t2 because of X.    If we knew beforehand that X is reassorted, we could simply ignore it while resolving t2.    The (D,E,X) split in t1 would become (D,E), which is compatible with t2, and the resolve! function would handle this.  ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"However, the topology-based heuristic used by RecombTools is not able to detect that X is the only reassorted leaf if the trees are not resolved!   Indeed, if we \"remove\" X from the trees, some incompatibilities will remain.    For instance, the split above E will be (D,E) in the first tree and (C,D,E) in the second.    Without resolving, the heuristic will predict a reassortment above almost every leaf: ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"computeMCCs(Dict(1 => t1, 2 => t2), OptArgs(;resolve=false))[1,2]","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"In order to achieve progress in this kind of situation, we have to perform two operations at the same time: ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"realize that X is the only reassorted strain, and can be ignored when resolving.\nresolve t2 with the (D,E,X) split, ignoring X. ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"This is done automatically during MCC inference if the resolve option of OptArgs is given (default):  ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"MCCs = computeMCCs(Dict(1 => t1, 2 => t2), OptArgs(;resolve=true))[1,2]","category":"page"},{"location":"resolving/#Resolving-with-inferred-MCCs","page":"Resolving","title":"Resolving with inferred MCCs","text":"","category":"section"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"Once the MCCs are inferred, it is possible to use them to resolve trees: in the regions of shared branches of the ARG, the two trees t1 and t2 must have the same splits.    The resolve! function also has a method for this.    Using the example above, we have","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"resolved_splits = resolve!(t1, t2, MCCs)\nt2","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"The split (D,E) is now present in t2.  Note that it was not present in t1: only the splits (D,E,X) and (E,X) existed there.  However, since resolve! now knows (A,B,C,D,E) is an MCC, the resolve! function can \"ignore\" leaf X when resolving. ","category":"page"},{"location":"resolving/#Pre-resolving-for-more-than-two-trees","page":"Resolving","title":"Pre-resolving for more than two trees","text":"","category":"section"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"Implemented, but not used.  ","category":"page"},{"location":"types/","page":"OptArgs","title":"OptArgs","text":"CurrentModule = RecombTools","category":"page"},{"location":"types/#The-OptArgs-object","page":"OptArgs","title":"The OptArgs object","text":"","category":"section"},{"location":"types/","page":"OptArgs","title":"OptArgs","text":"computeMCCs and several other functions take an OptArgs object that controls several parameters of the inference process. ","category":"page"},{"location":"types/","page":"OptArgs","title":"OptArgs","text":"OptArgs","category":"page"},{"location":"types/#RecombTools.OptArgs","page":"OptArgs","title":"RecombTools.OptArgs","text":"struct OptArgs\n\nStoring parameters for SplitGraph.runopt function.\n\nGeneral\n\nγ::Real = 2\nitmax::Int64 = 15: maximal number of iterations of naive MCCs / SA cycles.\nlikelihood_sort::Bool = true: sort equivalent configurations using likelihood test based on branch length.\nresolve::Bool = true: try to resolve trees while finding MCCs.\nseq_lengths: lengths of sequences that trees were built from. Used in likelihood calculations. This is initialized from other input arguments, and defaults to sequences of length one.\n\nSimulated annealing\n\nMd::Real = 10:  number of SA iterations (per temperature) for a tree of n leaves is ceil(Int, n/Md).\ncooling_schedule = :geometric: type of cooling schedule (:geometric, :linear)\nTmin::Float64 = 1e-3: minimal temperature of SA.\nTmax::Float64 = 1: maximal temperature of SA.\nαT::Float64 = 0.95: ratio between terms in the geometric cooling.\ndT::Float64 = 1e-2: temperature step in the linear cooling.\n\nVerbosity\n\nverbose::Bool=false: first level of verbosity\nvv::Bool = false: second level of verbosity\n\nOutput\n\noutput = :mccs: possible values [:mccs, :mccs_df, :all]. If calling computeMCCs, this should always be set to :mccs. Other values are only relevant when directly calling runopt.\n\n\n\n\n\n","category":"type"}]
./docs/build/mccs/index.html:<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>MCCs · RecombTools documentation</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">RecombTools documentation</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Index</a></li><li><span class="tocitem">Usage</span><ul><li><a class="tocitem" href="../overview/">Overview</a></li><li class="is-active"><a class="tocitem" href>MCCs</a><ul class="internal"><li><a class="tocitem" href="#Handling-trees"><span>Handling trees</span></a></li><li><a class="tocitem" href="#Simple-case"><span>Simple case</span></a></li><li><a class="tocitem" href="#Interpretation-of-results"><span>Interpretation of results</span></a></li><li><a class="tocitem" href="#More-than-two-trees"><span>More than two trees</span></a></li><li><a class="tocitem" href="#naive_mccs"><span>Naive estimation</span></a></li></ul></li><li><a class="tocitem" href="../options/">Important options</a></li></ul></li><li><span class="tocitem">Under the hood</span><ul><li><a class="tocitem" href="../opttrees/"><code>opttrees</code></a></li><li><a class="tocitem" href="../runopt/"><code>runopt</code></a></li><li><a class="tocitem" href="../resolving/">Resolving</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../types/">OptArgs</a></li><li><a class="tocitem" href="../functions/">Functions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Usage</a></li><li class="is-active"><a href>MCCs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>MCCs</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PierreBarrat/RecombTools/blob/master/docs/src/mccs.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Maximally-Compatible-Clades"><a class="docs-heading-anchor" href="#Maximally-Compatible-Clades">Maximally Compatible Clades</a><a id="Maximally-Compatible-Clades-1"></a><a class="docs-heading-anchor-permalink" href="#Maximally-Compatible-Clades" title="Permalink"></a></h1><p><em>RecombTools</em> reconstructs the ARG from trees by first inferring Maximally Compatible Clades (MCC). </p><h2 id="Handling-trees"><a class="docs-heading-anchor" href="#Handling-trees">Handling trees</a><a id="Handling-trees-1"></a><a class="docs-heading-anchor-permalink" href="#Handling-trees" title="Permalink"></a></h2><p>Functions that directly handle trees are found in the separate <em>TreeTools</em> package.    Here is a short list of useful ones: </p><ul><li><code>read_tree(file)</code>: read tree from newick file, return <code>Tree</code> object. </li><li><code>parse_newick(string)</code>: parse newick <code>string</code> into a <code>TreeNode</code> object.</li><li><code>node2tree(n::TreeNode)</code>: create a <code>Tree</code> object from node <code>n</code>, using it as a root. </li><li><code>write_newick(file::String, t::Tree)</code>/<code>write_newick([file::String], n::TreeNode)</code>: write tree to <code>file</code> using newick format. Return a newick string if <code>file</code> is not provided. </li></ul><h2 id="Simple-case"><a class="docs-heading-anchor" href="#Simple-case">Simple case</a><a id="Simple-case-1"></a><a class="docs-heading-anchor-permalink" href="#Simple-case" title="Permalink"></a></h2><p>Let&#39;s see how to infer Maximally Compatible Clades (MCC) for a very simple case: two trees with five leaves. </p><pre><code class="language-julia hljs">using RecombTools
./docs/build/mccs/index.html: [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;]</code></pre><p>Individual MCCs are simply arrays containing labels of leaves of the trees.  </p><h2 id="Interpretation-of-results"><a class="docs-heading-anchor" href="#Interpretation-of-results">Interpretation of results</a><a id="Interpretation-of-results-1"></a><a class="docs-heading-anchor-permalink" href="#Interpretation-of-results" title="Permalink"></a></h2><p>The genealogy of two RNA segments subject to reassortment is described by an Ancestral Reassortment Graph (ARG).  An ARG is a directed graph that represents the lineage of a given pair of segments by coalescence of nodes, as in a genealogical tree, but also shows reassortment events and the exchange of segments by nodes that have two ancestors.  Since reassortments only occur between segments, the genealogy of given segment is described by a tree.  As a result, the ARG must embed both segment-trees, and every branch in the ARG has to belong to either one of the trees, or to both. </p><p><em>RecombTools</em> infers the ARG by finding the branches that are common to both trees.  Given two trees with potentially different topologies, it tries to &quot;glue&quot; them together in a reasonable way, where the interpretation of reasonable can vary between <em>parsimonious</em> and <em>conservative</em> (see the <a href="../options/#gamma">parsimony parameter</a> <span>$\gamma$</span>). </p><p>The MCCs returned by <code>computeMCCs</code> represent regions of the ARG (and of the segment trees) where branches are common to both trees.  In other words, these are the regions where the two segment trees must be &quot;glued together&quot;.  Given those regions and the knowledge of the trees, it is possible to unambiguously reconstruct the genealogy. </p><div class="admonition is-info"><header class="admonition-header">Number of reassortments in the genealogy</header><div class="admonition-body"><p>When going up the ARG (backwards in time), a reassortment consists of passing from a region where branches are common to the two trees to a region where they are not. It is a <em>split</em> of branches.  As a consequence, the root of each MCC must be a reassortment, <em>with the exception</em> of an MCC containing the root of both trees.  The number of reassortments events in the inferred ARG can thus simply be obtained by counting the number of MCCs, potentially removing the one that contains the roots of both trees if it exists. </p></div></div><h2 id="More-than-two-trees"><a class="docs-heading-anchor" href="#More-than-two-trees">More than two trees</a><a id="More-than-two-trees-1"></a><a class="docs-heading-anchor-permalink" href="#More-than-two-trees" title="Permalink"></a></h2><p>If more than two trees are given as input, <code>computeMCCs</code> infers MCCs for all pairs of trees.   Use a <code>Dict</code> to pass the trees as input. </p><pre><code class="language-julia hljs">t1 = node2tree(parse_newick(&quot;((A,B),((C,Y),(D,X)))&quot;))
./docs/build/runopt/index.html:<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>runopt · RecombTools documentation</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">RecombTools documentation</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Index</a></li><li><span class="tocitem">Usage</span><ul><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../mccs/">MCCs</a></li><li><a class="tocitem" href="../options/">Important options</a></li></ul></li><li><span class="tocitem">Under the hood</span><ul><li><a class="tocitem" href="../opttrees/"><code>opttrees</code></a></li><li class="is-active"><a class="tocitem" href><code>runopt</code></a></li><li><a class="tocitem" href="../resolving/">Resolving</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../types/">OptArgs</a></li><li><a class="tocitem" href="../functions/">Functions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Under the hood</a></li><li class="is-active"><a href><code>runopt</code></a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href><code>runopt</code></a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PierreBarrat/RecombTools/blob/master/docs/src/runopt.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="The-runopt-function"><a class="docs-heading-anchor" href="#The-runopt-function">The <code>runopt</code> function</a><a id="The-runopt-function-1"></a><a class="docs-heading-anchor-permalink" href="#The-runopt-function" title="Permalink"></a></h1><p>For larger trees, <code>opttrees</code> will not find all reassortments at once.    The reason for this is that it is often necessary to &quot;clean&quot; reassorted leaves in smaller clades in order to see other reassortments deeper in the tree.    As a consequence, trees obtained after one round of <code>opttrees</code> will still have incompatibilities.  Below is a relatively simple example of trees for which <code>opttrees</code> does not find all reassorted leaves in one go: </p><pre><code class="language-julia hljs">nwk1 = &quot;(Z,(G,(((A,X),(B,C)),((D,Y),(E,F)))))&quot;
./docs/build/runopt/index.html:mcc_names = RecombTools.name_mcc_clades!(treelist, mccs_naive)
./docs/build/runopt/index.html:  treelist[i] = RecombTools.reduce_to_mcc(t, mccs_naive)
./docs/build/runopt/index.html: [&quot;X&quot;]</code></pre><p>!!! info <span>$\gamma = 2$</span>     If you run this example using <span>$\gamma \leq 2$</span>, <code>Z</code> will immediatly be found as a reassorted strain.      It is indeed not easy to find example that combine trees with a small number of leaves (9 here), obvious reassortments, and that are not solved in one go by <code>opttrees</code> with a low value of <span>$\gamma$</span>.      However, when dealing with trees with hundreds of leaves, finding all MCCs in one go is the exception rather than the rule. </p><p>As expected, <code>X</code> <code>Y</code> are found as reassortants.    However, the two trees will still have incompatibilities when removing those two leaves.    To make this explicit, we remove the leaves <code>X</code> and <code>Y</code> and compute naive mccs again. </p><pre><code class="language-julia hljs">RecombTools.pruneconf!(mccs_found, treelist...) # prune clades in a list of trees. Wrapper around TreeTools.prunesutree!
./docs/build/runopt/index.html: [&quot;D&quot;, &quot;E&quot;, &quot;F&quot;]</code></pre><p>Now that <code>X</code> and <code>Y</code> are removed, we see that clades <code>ABC</code> and <code>DEF</code> are common to both trees.    If we reduce the pruned trees to their new naive MCCs again, we now see that <code>Z</code> is an obvious choice for a reassorted strain: </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; mcc_names = RecombTools.name_mcc_clades!(treelist, mccs_naive)</code><code class="nohighlight hljs ansi" style="display:block;">Dict{Any, Any} with 4 entries:
./docs/build/runopt/index.html:         treelist[i] = RecombTools.reduce_to_mcc(t, mccs_naive)
./docs/build/functions/index.html:<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions · RecombTools documentation</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">RecombTools documentation</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Index</a></li><li><span class="tocitem">Usage</span><ul><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../mccs/">MCCs</a></li><li><a class="tocitem" href="../options/">Important options</a></li></ul></li><li><span class="tocitem">Under the hood</span><ul><li><a class="tocitem" href="../opttrees/"><code>opttrees</code></a></li><li><a class="tocitem" href="../runopt/"><code>runopt</code></a></li><li><a class="tocitem" href="../resolving/">Resolving</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../types/">OptArgs</a></li><li class="is-active"><a class="tocitem" href>Functions</a><ul class="internal"><li><a class="tocitem" href="#Computing-Maximal-Compatible-Clades-(MCCs)-for-a-set-of-trees"><span>Computing Maximal Compatible Clades (MCCs) for a set of trees</span></a></li><li><a class="tocitem" href="#Resolving-trees"><span>Resolving trees</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href>Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PierreBarrat/RecombTools/blob/master/docs/src/functions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h1><ul><li><a href="#RecombTools.computeMCCs"><code>RecombTools.computeMCCs</code></a></li><li><a href="#RecombTools.computeMCCs!"><code>RecombTools.computeMCCs!</code></a></li><li><a href="#RecombTools.naive_mccs"><code>RecombTools.naive_mccs</code></a></li><li><a href="#RecombTools.resolve!-Tuple{TreeTools.Tree, TreeTools.Tree}"><code>RecombTools.resolve!</code></a></li><li><a href="#RecombTools.runopt"><code>RecombTools.runopt</code></a></li></ul><h2 id="Computing-Maximal-Compatible-Clades-(MCCs)-for-a-set-of-trees"><a class="docs-heading-anchor" href="#Computing-Maximal-Compatible-Clades-(MCCs)-for-a-set-of-trees">Computing Maximal Compatible Clades (MCCs) for a set of trees</a><a id="Computing-Maximal-Compatible-Clades-(MCCs)-for-a-set-of-trees-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-Maximal-Compatible-Clades-(MCCs)-for-a-set-of-trees" title="Permalink"></a></h2><h3 id="Main-functions"><a class="docs-heading-anchor" href="#Main-functions">Main functions</a><a id="Main-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Main-functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="RecombTools.computeMCCs" href="#RecombTools.computeMCCs"><code>RecombTools.computeMCCs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">computeMCCs(
./docs/build/functions/index.html:)</code></pre><p>Compute pairwise MCCs for trees. Return MCCs and resolved splits. The <code>computeMCCs!</code> version resolves the input trees with newly found splits.</p><p><strong>Inputs</strong></p><p><strong><code>oa::OptArgs</code></strong></p><p>Controls parameters of the MCC inference (unless <code>naive=true</code>). See <code>?OptArgs</code> for details.</p><p><strong><code>preresolve = false</code></strong></p><ul><li>If <code>true</code>, a first pass of MCC computation is made and trees are resolved using the results, keeping only compatible splits if more than two trees are given as input. A second pass of MCC computation is then made without resolving.</li><li>Else, only the first pass is performed. For more than two trees, this may find MCCs that introduce incompatible splits in case of poorly resolved input trees.</li></ul><p>In general, this should be set to <code>true</code> if more than two trees are used, and to <code>false</code>   for only two trees (for speed).</p><p><strong><code>naive = false</code></strong></p><ul><li>If <code>true</code>, use a naive estimation for MCCs, <em>i.e.</em> find all clades that have an exactly matching topology in all trees.</li><li>Else, use a pseudo-parsimonious method based (mostly) on topology. The method <code>runopt(oa,t1,t2)</code> is called on every pair of trees.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/RecombTools/blob/bb28b38e36dd4c279b3dab7bcb1b4fd5f81717af/src/main.jl#L17-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RecombTools.computeMCCs!" href="#RecombTools.computeMCCs!"><code>RecombTools.computeMCCs!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">computeMCCs!(
./docs/build/functions/index.html:)</code></pre><p>See <code>computeMCCs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/RecombTools/blob/bb28b38e36dd4c279b3dab7bcb1b4fd5f81717af/src/main.jl#L57-L64">source</a></section></article><h3 id="For-pairs-of-trees-only"><a class="docs-heading-anchor" href="#For-pairs-of-trees-only">For pairs of trees only</a><a id="For-pairs-of-trees-only-1"></a><a class="docs-heading-anchor-permalink" href="#For-pairs-of-trees-only" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="RecombTools.naive_mccs" href="#RecombTools.naive_mccs"><code>RecombTools.naive_mccs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">naive_mccs(treelist)</code></pre><p>Find sets of nodes which are:</p><ul><li>clades in all trees of <code>treelist</code>,</li><li>all subclades of nodes are clades in all trees of <code>treelist</code> (both of these properties define consistency),</li><li>maximal: adding a node to a set results it in not being a clade in at least one of the trees.</li></ul><p>All the trees of <code>treelist</code> should share the same leaf nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/RecombTools/blob/bb28b38e36dd4c279b3dab7bcb1b4fd5f81717af/src/mcc_base.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RecombTools.runopt" href="#RecombTools.runopt"><code>RecombTools.runopt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">	runopt(t1::Tree, t2::Tree; kwargs...)
./docs/build/functions/index.html:	runopt(oa::OptArgs, trees::Dict{&lt;:Any,&lt;:Tree})</code></pre><p>Run optimization at constant γ. See <code>?Optargs</code> for arguments. In the first form, keyword   arguments are given to <code>OptArgs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/RecombTools/blob/bb28b38e36dd4c279b3dab7bcb1b4fd5f81717af/src/main.jl#L149-L156">source</a></section></article><h2 id="Resolving-trees"><a class="docs-heading-anchor" href="#Resolving-trees">Resolving trees</a><a id="Resolving-trees-1"></a><a class="docs-heading-anchor-permalink" href="#Resolving-trees" title="Permalink"></a></h2><h3 id="Using-topology"><a class="docs-heading-anchor" href="#Using-topology">Using topology</a><a id="Using-topology-1"></a><a class="docs-heading-anchor-permalink" href="#Using-topology" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="RecombTools.resolve!-Tuple{TreeTools.Tree, TreeTools.Tree}" href="#RecombTools.resolve!-Tuple{TreeTools.Tree, TreeTools.Tree}"><code>RecombTools.resolve!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">resolve!(t1::Tree, t2::Tree; tau=0.)</code></pre><p>Resolve <code>t1</code> using splits of <code>t2</code> and inversely. Every split of <code>t2</code> a tree that is compatible with <code>t1</code> is introduced in <code>t1</code> with branch length <code>tau</code> (and inversely). Return new splits in each tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/RecombTools/blob/bb28b38e36dd4c279b3dab7bcb1b4fd5f81717af/src/resolving.jl#L128-L132">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../types/">« OptArgs</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Tuesday 26 October 2021 17:12">Tuesday 26 October 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
./docs/build/types/index.html:<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>OptArgs · RecombTools documentation</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">RecombTools documentation</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Index</a></li><li><span class="tocitem">Usage</span><ul><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../mccs/">MCCs</a></li><li><a class="tocitem" href="../options/">Important options</a></li></ul></li><li><span class="tocitem">Under the hood</span><ul><li><a class="tocitem" href="../opttrees/"><code>opttrees</code></a></li><li><a class="tocitem" href="../runopt/"><code>runopt</code></a></li><li><a class="tocitem" href="../resolving/">Resolving</a></li></ul></li><li><span class="tocitem">Library</span><ul><li class="is-active"><a class="tocitem" href>OptArgs</a></li><li><a class="tocitem" href="../functions/">Functions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href>OptArgs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>OptArgs</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PierreBarrat/RecombTools/blob/master/docs/src/types.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="The-OptArgs-object"><a class="docs-heading-anchor" href="#The-OptArgs-object">The <code>OptArgs</code> object</a><a id="The-OptArgs-object-1"></a><a class="docs-heading-anchor-permalink" href="#The-OptArgs-object" title="Permalink"></a></h1><p><code>computeMCCs</code> and several other functions take an <code>OptArgs</code> object that controls several parameters of the inference process. </p><article class="docstring"><header><a class="docstring-binding" id="RecombTools.OptArgs" href="#RecombTools.OptArgs"><code>RecombTools.OptArgs</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct OptArgs</code></pre><p>Storing parameters for <code>SplitGraph.runopt</code> function.</p><p><strong>General</strong></p><ul><li><code>γ::Real = 2</code></li><li><code>itmax::Int64 = 15</code>: maximal number of iterations of naive MCCs / SA cycles.</li><li><code>likelihood_sort::Bool = true</code>: sort equivalent configurations using likelihood test based on branch length.</li><li><code>resolve::Bool = true</code>: try to resolve trees while finding MCCs.</li><li><code>seq_lengths</code>: lengths of sequences that trees were built from. Used in likelihood calculations. This is initialized from other input arguments, and defaults to sequences of length one.</li></ul><p><strong>Simulated annealing</strong></p><ul><li><code>Md::Real = 10</code>:  number of SA iterations (per temperature) for a tree of <code>n</code> leaves is <code>ceil(Int, n/Md)</code>.</li><li><code>cooling_schedule = :geometric</code>: type of cooling schedule <code>(:geometric, :linear)</code></li><li><code>Tmin::Float64 = 1e-3</code>: minimal temperature of SA.</li><li><code>Tmax::Float64 = 1</code>: maximal temperature of SA.</li><li><code>αT::Float64 = 0.95</code>: ratio between terms in the geometric cooling.</li><li><code>dT::Float64 = 1e-2</code>: temperature step in the linear cooling.</li></ul><p><strong>Verbosity</strong></p><ul><li><code>verbose::Bool=false</code>: first level of verbosity</li><li><code>vv::Bool = false</code>: second level of verbosity</li></ul><p><strong>Output</strong></p><ul><li><code>output = :mccs</code>: possible values <code>[:mccs, :mccs_df, :all]</code>. If calling <code>computeMCCs</code>, this should always be set to <code>:mccs</code>. Other values are only relevant when directly calling <code>runopt</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/RecombTools/blob/bb28b38e36dd4c279b3dab7bcb1b4fd5f81717af/src/objects.jl#L1-L30">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../resolving/">« Resolving</a><a class="docs-footer-nextpage" href="../functions/">Functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Tuesday 26 October 2021 17:12">Tuesday 26 October 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
./docs/build/flu_example/index.html:<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Flu example · RecombTools documentation</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">RecombTools documentation</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Index</a></li><li><span class="tocitem">Usage</span><ul><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../mccs/">MCCs</a></li><li><a class="tocitem" href="../options/">Important options</a></li></ul></li><li><span class="tocitem">Under the hood</span><ul><li><a class="tocitem" href="../opttrees/"><code>opttrees</code></a></li><li><a class="tocitem" href="../runopt/"><code>runopt</code></a></li><li><a class="tocitem" href="../resolving/">Resolving</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../types/">OptArgs</a></li><li><a class="tocitem" href="../functions/">Functions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Flu example</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Flu example</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PierreBarrat/RecombTools/blob/master/docs/src/flu_example.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Flu-example"><a class="docs-heading-anchor" href="#Flu-example">Flu example</a><a id="Flu-example-1"></a><a class="docs-heading-anchor-permalink" href="#Flu-example" title="Permalink"></a></h1><p><em>RecombTools</em> includes the small submodule <em>Flu</em> that contains convenient functions when working with influenza trees.    To infer MCCs from a pair of influenza trees, we first use the <code>Flu.read_flu_trees</code> function that takes a dictionary pointing to newick files as input: </p><pre><code class="language-julia hljs">using RecombTools
./docs/build/flu_example/index.html:	&quot;ha&quot; =&gt; dirname(pathof(RecombTools)) * &quot;/../examples/tree_h3n2_ha_2013-09.nwk&quot;,
./docs/build/flu_example/index.html:	&quot;na&quot; =&gt; dirname(pathof(RecombTools)) * &quot;/../examples/tree_h3n2_na_2013-09.nwk&quot;
./docs/build/flu_example/index.html:  &quot;ha&quot; =&gt; </code></pre><p><code>read_flu_trees</code> does two things: </p><ul><li>read input trees and store them in a <code>Dict{String, Tree}</code>, which is the input format of <code>computeMCCs</code></li><li>remove &quot;short&quot; branches from the trees.  Some tree builders introduce branches of insignificant length in trees to make them binary, which conflicts with the topological approach used by <code>RecombTools</code>.  It is necessary to remove these branches.  The threshold below which a branch is removed is <span>$\frac{1}{2L}$</span> where <span>$L$</span> is the length of the gene sequence. </li></ul><p>We can now simply infer MCCs for these trees:</p><pre><code class="language-julia hljs">computeMCCs(flutrees)[&quot;ha&quot;, &quot;na&quot;]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">13-element Vector{Vector{String}}:
./docs/build/search/index.html:<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Search · RecombTools documentation</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">RecombTools documentation</a></span></div><form class="docs-search" action><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Index</a></li><li><span class="tocitem">Usage</span><ul><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../mccs/">MCCs</a></li><li><a class="tocitem" href="../options/">Important options</a></li></ul></li><li><span class="tocitem">Under the hood</span><ul><li><a class="tocitem" href="../opttrees/"><code>opttrees</code></a></li><li><a class="tocitem" href="../runopt/"><code>runopt</code></a></li><li><a class="tocitem" href="../resolving/">Resolving</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../types/">OptArgs</a></li><li><a class="tocitem" href="../functions/">Functions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Search</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Search</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article><p id="documenter-search-info">Loading search...</p><ul id="documenter-search-results"></ul></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Tuesday 26 October 2021 17:12">Tuesday 26 October 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><script src="../search_index.js"></script><script src="../assets/search.js"></script></html>
./docs/build/resolving/index.html:<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Resolving · RecombTools documentation</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">RecombTools documentation</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Index</a></li><li><span class="tocitem">Usage</span><ul><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../mccs/">MCCs</a></li><li><a class="tocitem" href="../options/">Important options</a></li></ul></li><li><span class="tocitem">Under the hood</span><ul><li><a class="tocitem" href="../opttrees/"><code>opttrees</code></a></li><li><a class="tocitem" href="../runopt/"><code>runopt</code></a></li><li class="is-active"><a class="tocitem" href>Resolving</a><ul class="internal"><li><a class="tocitem" href="#Resolving-pairs-of-trees"><span>Resolving pairs of trees</span></a></li><li><a class="tocitem" href="#Resolving-during-MCC-inference"><span>Resolving during MCC inference</span></a></li><li><a class="tocitem" href="#Resolving-with-inferred-MCCs"><span>Resolving with inferred MCCs</span></a></li><li><a class="tocitem" href="#Pre-resolving-for-more-than-two-trees"><span>Pre-resolving for more than two trees</span></a></li></ul></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../types/">OptArgs</a></li><li><a class="tocitem" href="../functions/">Functions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Under the hood</a></li><li class="is-active"><a href>Resolving</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Resolving</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PierreBarrat/RecombTools/blob/master/docs/src/resolving.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Resolving"><a class="docs-heading-anchor" href="#Resolving">Resolving</a><a id="Resolving-1"></a><a class="docs-heading-anchor-permalink" href="#Resolving" title="Permalink"></a></h1><p>The lack of resolution in the inference of phylogenetic trees results in <em>polytomies</em>: internal nodes with more than two offsprings.    Polytomies can cause the topology of two trees to differ, which cause problems when inferring reassortments using topological information.    Suppose for instance that we have a first tree (<em>e.g.</em> for a given segment of flu): </p><pre><code class="language-julia hljs">t1 = node2tree(parse_newick(&quot;(A,(B,C))&quot;))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"> ----- NODE_1:missing
./docs/build/resolving/index.html:isempty(new_splits[2])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>Indeed, there is no split in <code>t1</code> that can directly help us resolve <code>t2</code>.    The closest such split is <code>(D,E,X)</code>, but it is incompatible with <code>t2</code> because of <code>X</code>.    If we knew beforehand that <code>X</code> is reassorted, we could simply ignore it while resolving <code>t2</code>.    The <code>(D,E,X)</code> split in <code>t1</code> would become <code>(D,E)</code>, which is compatible with <code>t2</code>, and the <code>resolve!</code> function would handle this.  </p><p>However, the topology-based heuristic used by <em>RecombTools</em> is not able to detect that <code>X</code> is the only reassorted leaf <em>if the trees are not resolved</em>!   Indeed, if we &quot;remove&quot; <code>X</code> from the trees, some incompatibilities will remain.    For instance, the split above <code>E</code> will be <code>(D,E)</code> in the first tree and <code>(C,D,E)</code> in the second.    Without resolving, the heuristic will predict a reassortment above almost every leaf: </p><pre><code class="language-julia hljs">computeMCCs(Dict(1 =&gt; t1, 2 =&gt; t2), OptArgs(;resolve=false))[1,2]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Vector{String}}:
./docs/build/overview/index.html:<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Overview · RecombTools documentation</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">RecombTools documentation</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Index</a></li><li><span class="tocitem">Usage</span><ul><li class="is-active"><a class="tocitem" href>Overview</a><ul class="internal"><li><a class="tocitem" href="#Input"><span>Input</span></a></li><li><a class="tocitem" href="#Output"><span>Output</span></a></li><li><a class="tocitem" href="#Options"><span>Options</span></a></li></ul></li><li><a class="tocitem" href="../mccs/">MCCs</a></li><li><a class="tocitem" href="../options/">Important options</a></li></ul></li><li><span class="tocitem">Under the hood</span><ul><li><a class="tocitem" href="../opttrees/"><code>opttrees</code></a></li><li><a class="tocitem" href="../runopt/"><code>runopt</code></a></li><li><a class="tocitem" href="../resolving/">Resolving</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../types/">OptArgs</a></li><li><a class="tocitem" href="../functions/">Functions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Usage</a></li><li class="is-active"><a href>Overview</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Overview</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PierreBarrat/RecombTools/blob/master/docs/src/overview.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h1><p><code>RecombTools</code> offers a simple CLI script: <code>treeknit</code>.  In short, it takes two trees as input, passed as <a href="https://en.wikipedia.org/wiki/Newick_format">Newick</a> files, and returns an Ancestral Reassortment Graph. </p><h2 id="Input"><a class="docs-heading-anchor" href="#Input">Input</a><a id="Input-1"></a><a class="docs-heading-anchor-permalink" href="#Input" title="Permalink"></a></h2><p>Inputs to <code>treeknit</code> are two files containing trees in Newick format.  The only strict condition on the trees is that they share their leaf nodes.  Example: </p><pre><code class="nohighlight hljs">recombtools treeknit tree1.nwk tree2.nwk</code></pre><div class="admonition is-warning"><header class="admonition-header">Insignificant branches</header><div class="admonition-body"><p>Tree builders sometimes introduce branches of insignificant length in order to resolve polytomies and obtain binary trees. Since <code>RecombTools</code> relies on topological differences between trees, it is important to remove these branches prior to passing the trees to <code>treeknit</code>. This can be done by using only branches with high bootstrap value (typically, <span>$&gt;75$</span>), or by removing branches shorter than, <em>e.g.</em>, <span>$(L/2)^{-1}$</span>, where <span>$L$</span> is the length of the sequences. </p></div></div><div class="admonition is-warning"><header class="admonition-header">Rooting the trees</header><div class="admonition-body"><p>The result <code>RecombTools</code> depend how the trees are rooted. It is important that the two trees are rooted in a consistent way. We recommend using the same outgroup for rooting both trees.</p></div></div><h2 id="Output"><a class="docs-heading-anchor" href="#Output">Output</a><a id="Output-1"></a><a class="docs-heading-anchor-permalink" href="#Output" title="Permalink"></a></h2><p>Output of the inference is written a directory called <code>treeknit_results</code>. This can be changed using the <code>--outdir</code> option.    The directory will contain:   </p><ul><li>the ARG, written as an extended <a href="https://doi.org/10.1186/1471-2105-9-532">Newick string</a>.   </li><li>the MCCs, <em>i.e.</em> shared regions of the trees, indicated by the leaves they contain.  </li><li>resolved trees, where polytomies have been reduced as much as possible using the knowledge of the MCCs.   </li><li>a table with the correspondence between internal nodes of the ARG and the trees. Note that this refers to node labels of the resolved trees, which may not be the same as the ones given as input.   </li></ul><h2 id="Options"><a class="docs-heading-anchor" href="#Options">Options</a><a id="Options-1"></a><a class="docs-heading-anchor-permalink" href="#Options" title="Permalink"></a></h2><p>The main options that you can play with are:  </p><ul><li>the parsimony parameter <span>$\gamma$</span>, <code>--gamma</code> or <code>-g</code>.   </li><li>naive inference <code>--naive</code>. Using this flag is equivalent to setting <span>$\gamma \rightarrow \infty$</span>.  </li><li>Length of sequences used to infer trees: <code>--seq-lengths</code>. These are used for likelihood test to break degeneracy between topologically equivalent MCCs.  </li></ul><p>More details in the <a href="../options/#options">options section</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Index</a><a class="docs-footer-nextpage" href="../mccs/">MCCs »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Tuesday 26 October 2021 17:12">Tuesday 26 October 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
./docs/build/options/index.html:<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Important options · RecombTools documentation</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">RecombTools documentation</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Index</a></li><li><span class="tocitem">Usage</span><ul><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../mccs/">MCCs</a></li><li class="is-active"><a class="tocitem" href>Important options</a><ul class="internal"><li><a class="tocitem" href="#gamma"><span>Parsimony parameter</span></a></li><li><a class="tocitem" href="#Resolving-trees-with-polytomies"><span>Resolving trees with polytomies</span></a></li><li><a class="tocitem" href="#likelihood"><span>Degeneracy: sorting with likelihood</span></a></li></ul></li></ul></li><li><span class="tocitem">Under the hood</span><ul><li><a class="tocitem" href="../opttrees/"><code>opttrees</code></a></li><li><a class="tocitem" href="../runopt/"><code>runopt</code></a></li><li><a class="tocitem" href="../resolving/">Resolving</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../types/">OptArgs</a></li><li><a class="tocitem" href="../functions/">Functions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Usage</a></li><li class="is-active"><a href>Important options</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Important options</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PierreBarrat/RecombTools/blob/master/docs/src/options.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="options"><a class="docs-heading-anchor" href="#options">Options</a><a id="options-1"></a><a class="docs-heading-anchor-permalink" href="#options" title="Permalink"></a></h1><p><code>computeMCCs</code> uses a topogy based heuristic optimization to find maximally compatible clades.    Options to this heuristic are provided through the <code>OptArgs</code> object, that is optionally passed as a second argument.   Essential options are detailed here. 	</p><h2 id="gamma"><a class="docs-heading-anchor" href="#gamma">Parsimony parameter</a><a id="gamma-1"></a><a class="docs-heading-anchor-permalink" href="#gamma" title="Permalink"></a></h2><p>The heuristic method used by <em>RecombTools</em> tries to prune consistent clades from a pair of trees in order to increase a compatibility score between other clades.    Pruning a clade is interpreted as fixing a reassortment right above it, while increasing the compatibility between remaining clades removes reassortments.    A purely parsimonious heuristic should thus give the same weight to fixing a reassortment through pruning a clade and fixing one incompatibility in the trees. </p><p>Here, we assign the score <span>$\gamma$</span> to each pruned clade, and count as <span>$1$</span> each incompatibility fixed for the remaining clades.    For <span>$\gamma=1$</span>, we obtain a parsimonious method that attempts to minimize the overall number of reassortments.    For higher values, pruning a clade must &quot;fix&quot; at least <span>$\gamma$</span> incompatibilities to be considered a good move, making the obtained MCCs less parsimonious.    For infinite <span>$\gamma$</span>, pruning clades is impossible, and we fall back on the <a href="../mccs/#naive_mccs">naive estimation of MCCs</a>. </p><p>The example below illustrates the difference between different <span>$\gamma$</span> values: </p><pre><code class="language-julia hljs">t1 = node2tree(parse_newick(&quot;((((A,B),C),D),E)&quot;))
